 Promise á€†á€­á€¯á€á€¬ á€˜á€¬á€œá€²?
 ---------------------
Promise á€†á€­á€¯á€á€¬ Node.js (á€”á€²á€· JavaScript) á€™á€¾á€¬
á€¡á€á€»á€­á€”á€ºá€šá€° á€œá€¯á€•á€ºá€†á€±á€¬á€„á€ºá€›á€á€²á€· á€¡á€œá€¯á€•á€º (asynchronous operation) á€á€…á€ºá€á€¯á€›á€²á€· 
á€”á€±á€¬á€€á€ºá€†á€¯á€¶á€¸ á€•á€¼á€®á€¸á€™á€¼á€±á€¬á€€á€ºá€™á€¾á€¯ (á€á€­á€¯á€·) á€™á€¡á€±á€¬á€„á€ºá€™á€¼á€„á€ºá€™á€¾á€¯ á€”á€²á€· á€¡á€²á€’á€®á€€ á€›á€›á€¾á€­á€œá€¬á€á€²á€· á€á€”á€ºá€–á€­á€¯á€¸ (value) á€€á€­á€¯ á€€á€­á€¯á€šá€ºá€…á€¬á€¸á€•á€¼á€¯á€á€²á€·
object á€á€…á€ºá€á€¯ á€–á€¼á€…á€ºá€•á€«á€á€šá€ºá‹


á€¥á€•á€™á€¬á€¡á€¬á€¸á€–á€¼á€„á€·á€ºáŠ á€á€„á€º á€…á€¬á€¸á€á€±á€¬á€€á€ºá€†á€­á€¯á€„á€ºá€™á€¾á€¬ á€¡á€…á€¬á€¸á€¡á€á€±á€¬á€€á€º á€™á€¾á€¬á€šá€°á€á€¬ á€”á€²á€· á€á€°á€•á€«á€á€šá€ºá‹

á€á€„á€º á€¡á€±á€¬á€ºá€’á€« á€™á€¾á€¬á€œá€­á€¯á€€á€ºá€á€²á€·á€¡á€á€« (á€¡á€á€»á€­á€”á€ºá€šá€°á€›á€á€²á€· á€¡á€œá€¯á€•á€ºá€á€…á€ºá€á€¯á€€á€­á€¯ á€…á€á€„á€ºá€œá€­á€¯á€€á€ºá€á€²á€·á€¡á€á€«)áŠ á€¡á€…á€¬á€¸á€¡á€á€±á€¬á€€á€ºá€€á€­á€¯ á€á€»á€€á€ºá€á€»á€„á€ºá€¸á€™á€›á€•á€«á€˜á€°á€¸á‹

á€¡á€…á€¬á€¸á€‘á€­á€¯á€¸á€¡á€”á€±á€”á€²á€·áŠ á€…á€¬á€¸á€•á€½á€²á€‘á€­á€¯á€¸á€€ á€á€„á€·á€ºá€€á€­á€¯ á€¡á€±á€¬á€ºá€’á€« á€œá€€á€ºá€™á€¾á€á€º (Promise) á€á€…á€ºá€á€¯ á€•á€±á€¸á€•á€«á€á€šá€ºá‹

á€’á€®á€œá€€á€ºá€™á€¾á€á€ºá€€ á€á€„á€·á€ºá€€á€­á€¯ á€”á€±á€¬á€€á€ºá€†á€¯á€¶á€¸á€™á€¾á€¬ á€¡á€±á€¬á€€á€ºá€•á€«á€¡á€á€­á€¯á€„á€ºá€¸ á€›á€œá€­á€™á€·á€ºá€™á€šá€ºá€œá€­á€¯á€· á€¡á€¬á€™á€á€¶á€•á€±á€¸á€‘á€¬á€¸á€•á€«á€á€šá€º-

á€¡á€œá€¯á€•á€º á€¡á€±á€¬á€„á€ºá€™á€¼á€„á€ºá€›á€„á€ºáŠ á€á€„á€·á€ºá€›á€²á€· á€¡á€…á€¬á€¸á€¡á€á€±á€¬á€€á€º (fulfilled value) á€€á€­á€¯ á€›á€•á€«á€™á€šá€ºá‹

á€¡á€œá€¯á€•á€º á€™á€¡á€±á€¬á€„á€ºá€™á€¼á€„á€ºá€›á€„á€ºáŠ á€˜á€¬á€€á€¼á€±á€¬á€„á€·á€ºá€™á€›á€œá€²á€†á€­á€¯á€á€²á€· á€¡á€€á€¼á€±á€¬á€„á€ºá€¸á€•á€¼á€á€»á€€á€º (rejection reason/error) á€€á€­á€¯ á€›á€•á€«á€™á€šá€ºá‹

//////////////////////////////////////////////////////////////////////////////////////

Promise á€›á€²á€· á€¡á€á€¼á€±á€¡á€”á€± á€á€¯á€¶á€¸á€™á€»á€­á€¯á€¸ (The Three States)

Promise object á€Ÿá€¬ á€¡á€™á€¼á€²á€á€™á€ºá€¸ á€¡á€á€¼á€±á€¡á€”á€± á€á€¯á€¶á€¸á€™á€»á€­á€¯á€¸á€‘á€²á€€ á€á€…á€ºá€á€¯á€á€¯á€™á€¾á€¬ á€›á€¾á€­á€”á€±á€•á€«á€á€šá€º-

Pending (á€…á€±á€¬á€„á€·á€ºá€†á€­á€¯á€„á€ºá€¸á€†á€²): á€…á€á€„á€ºá€á€²á€· á€¡á€á€¼á€±á€¡á€”á€±á€•á€«á‹ á€¡á€á€»á€­á€”á€ºá€šá€°á€›á€á€²á€· á€¡á€œá€¯á€•á€ºá€€ á€œá€¯á€•á€ºá€†á€±á€¬á€„á€ºá€”á€±á€†á€²á€–á€¼á€…á€ºá€•á€«á€á€šá€ºá‹ (á€¡á€…á€¬á€¸á€¡á€á€±á€¬á€€á€º á€…á€±á€¬á€„á€·á€ºá€”á€±á€á€¬á€”á€²á€· á€á€°á€•á€«á€á€šá€º)

Fulfilled (á€á€­á€¯á€·á€™á€Ÿá€¯á€á€º Resolved): á€¡á€œá€¯á€•á€ºá€€ á€¡á€±á€¬á€„á€ºá€™á€¼á€„á€ºá€…á€½á€¬ á€•á€¼á€®á€¸á€™á€¼á€±á€¬á€€á€ºá€á€½á€¬á€¸ á€•á€«á€•á€¼á€®á‹ á€›á€œá€’á€ºá€á€”á€ºá€–á€­á€¯á€¸ (result value) á€€á€­á€¯ á€›á€›á€¾á€­á€•á€«á€•á€¼á€®á‹

Rejected (á€•á€šá€ºá€á€»á€á€¶á€›): á€¡á€œá€¯á€•á€ºá€€ á€•á€»á€€á€ºá€€á€½á€€á€ºá€á€½á€¬á€¸ á€•á€«á€•á€¼á€®á‹ á€•á€»á€€á€ºá€€á€½á€€á€ºá€›á€á€²á€· á€¡á€€á€¼á€±á€¬á€„á€ºá€¸á€•á€¼á€á€»á€€á€º (error) á€€á€­á€¯ á€á€­á€›á€•á€«á€•á€¼á€®á‹



Pending á€¡á€á€¼á€±á€¡á€”á€±á€€á€”á€± Fulfilled á€á€­á€¯á€·á€™á€Ÿá€¯á€á€º Rejected á€€á€­á€¯ á€•á€¼á€±á€¬á€„á€ºá€¸á€œá€²á€”á€­á€¯á€„á€ºá€•á€«á€á€šá€ºá‹
 á€’á€«á€•á€±á€™á€²á€· á€á€…á€ºá€á€« Fulfilled á€á€­á€¯á€·á€™á€Ÿá€¯á€á€º Rejected á€–á€¼á€…á€ºá€á€½á€¬á€¸á€•á€¼á€®á€†á€­á€¯á€›á€„á€º Settled (á€†á€¯á€¶á€¸á€–á€¼á€á€ºá€•á€¼á€®á€¸) á€–á€¼á€…á€ºá€á€½á€¬á€¸á€•á€¼á€®á€¸ á€”á€±á€¬á€€á€ºá€‘á€•á€º á€¡á€á€¼á€±á€¡á€”á€± á€•á€¼á€±á€¬á€„á€ºá€¸á€œá€²á€™á€¾á€¬ á€™á€Ÿá€¯á€á€ºá€•á€«á€˜á€°á€¸á‹



âš™ï¸ How to Use Promises (á€¡á€á€¯á€¶á€¸á€•á€¼á€¯á€•á€¯á€¶)
You attach functions to a Promise using the .then() method
 to handle the successful result or the .catch() method to handle the failure (error).

.then(onFulfilled, onRejected):

The first function (onFulfilled) runs if the Promise is fulfilled.

The second (optional) function (onRejected) runs if the Promise is rejected.

.catch(onRejected): A shortcut for .then(null, onRejected). It's generally used to handle errors in a chain of Promises.

.finally(onFinally): Runs regardless of whether the Promise was fulfilled or rejected.

Promise á€á€½á€±á€€á€­á€¯ á€¡á€á€¯á€¶á€¸á€•á€¼á€¯á€á€²á€·á€¡á€á€«áŠ á€¡á€±á€¬á€„á€ºá€™á€¼á€„á€ºá€á€²á€· á€›á€œá€’á€ºá€€á€­á€¯ á€€á€­á€¯á€„á€ºá€á€½á€šá€ºá€–á€­á€¯á€· .then() method á€€á€­á€¯ á€á€¯á€¶á€¸á€•á€¼á€®á€¸áŠ 
á€•á€»á€€á€ºá€€á€½á€€á€ºá€™á€¾á€¯ (error) á€€á€­á€¯ á€€á€­á€¯á€„á€ºá€á€½á€šá€ºá€–á€­á€¯á€· .catch() method á€€á€­á€¯ á€¡á€á€¯á€¶á€¸á€•á€¼á€¯á€•á€«á€á€šá€ºá‹

.then(onFulfilled, onRejected):

á€•á€‘á€™ function (onFulfilled) á€€ Promise á€¡á€±á€¬á€„á€ºá€™á€¼á€„á€º (fulfilled) á€á€²á€·á€¡á€á€« á€¡á€œá€¯á€•á€ºá€œá€¯á€•á€ºá€•á€«á€á€šá€ºá‹

á€’á€¯á€á€­á€š function (optional) (onRejected) á€€ Promise á€•á€»á€€á€ºá€€á€½á€€á€º (rejected) á€á€²á€·á€¡á€á€« á€¡á€œá€¯á€•á€ºá€œá€¯á€•á€ºá€•á€«á€á€šá€ºá‹

.catch(onRejected): á€’á€«á€Ÿá€¬ .then(null, onRejected) á€›á€²á€· á€¡á€á€­á€¯á€€á€±á€¬á€€á€ºá€–á€¼á€…á€ºá€•á€«á€á€šá€ºá‹
 Promise á€á€½á€± á€†á€€á€ºá€á€­á€¯á€€á€ºá€á€»á€­á€á€ºá€†á€€á€ºá€›á€¬á€™á€¾á€¬ error á€á€½á€±á€€á€­á€¯ á€€á€­á€¯á€„á€ºá€á€½á€šá€ºá€–á€­á€¯á€· á€¡á€™á€»á€¬á€¸á€¡á€¬á€¸á€–á€¼á€„á€·á€º á€á€¯á€¶á€¸á€•á€«á€á€šá€ºá‹

.finally(onFinally): Promise á€¡á€±á€¬á€„á€ºá€™á€¼á€„á€ºá€á€Šá€ºá€–á€¼á€…á€ºá€…á€±áŠ á€•á€»á€€á€ºá€€á€½á€€á€ºá€á€Šá€ºá€–á€¼á€…á€ºá€…á€± á€¡á€™á€¼á€²á€á€™á€ºá€¸ á€¡á€œá€¯á€•á€ºá€œá€¯á€•á€ºá€•á€«á€á€šá€ºá‹

ğŸ¯ Benefit (á€¡á€€á€»á€­á€¯á€¸á€€á€»á€±á€¸á€‡á€°á€¸)
The main benefit of Promises is to avoid "Callback Hell"
(nested callbacks that are difficult to read and maintain) 
and to make asynchronous code appear and behave more like synchronous code,
especially when using the modern async/await syntax, which is built on top of Promises.

Promises á€›á€²á€· á€¡á€“á€­á€€ á€¡á€€á€»á€­á€¯á€¸á€€á€»á€±á€¸á€‡á€°á€¸á€€á€á€±á€¬á€· "Callback Hell"
 (á€–á€á€ºá€›á€á€€á€ºá€•á€¼á€®á€¸ á€‘á€­á€”á€ºá€¸á€á€­á€™á€ºá€¸á€›á€á€€á€ºá€á€²á€· á€¡á€œá€½á€¾á€¬á€œá€­á€¯á€€á€º á€‘á€•á€ºá€”á€±á€á€²á€· callbacks á€á€½á€±) á€€á€­á€¯ á€›á€¾á€±á€¬á€„á€ºá€›á€¾á€¬á€¸á€–á€­á€¯á€·á€”á€²á€·áŠ
á€á€±á€á€ºá€™á€®á€á€²á€· async/await syntax (Promise á€á€½á€±á€•á€±á€«á€ºá€™á€¾á€¬ á€á€Šá€ºá€†á€±á€¬á€€á€ºá€‘á€¬á€¸á€á€¬) á€€á€­á€¯
 á€¡á€á€¯á€¶á€¸á€•á€¼á€¯á€á€²á€·á€¡á€á€« á€¡á€á€»á€­á€”á€ºá€šá€°á€›á€á€²á€· code á€á€½á€±á€€á€­á€¯ á€›á€­á€¯á€¸á€›á€¾á€„á€ºá€¸á€á€²á€· code á€á€½á€±á€œá€­á€¯ á€™á€¼á€„á€ºá€›á€•á€¼á€®á€¸ á€œá€¯á€•á€ºá€†á€±á€¬á€„á€ºá€”á€­á€¯á€„á€ºá€…á€±á€–á€­á€¯á€·á€•á€² á€–á€¼á€…á€ºá€•á€«á€á€šá€ºá‹


 =======================================================================================================================
 =======================================================================================================================

Async/await
Thereâ€™s a special syntax to work with promises in a more comfortable fashion, called â€œasync/awaitâ€.
 Itâ€™s surprisingly easy to understand and use.

Async functions
Letâ€™s start with the async keyword. It can be placed before a function, like this:


async function f() {
  return 1;
}


The word â€œasyncâ€ before a function means one simple thing: a function always returns a promise.
 Other values are wrapped in a resolved promise automatically.

For instance, this function returns a resolved promise with the result of 1; letâ€™s test it:

async function f() {
  return 1;
}

f().then(alert); // 1


â€¦We could explicitly return a promise, which would be the same:

async function f() {
  return Promise.resolve(1);
}

f().then(alert); // 1

So, async ensures that the function returns a promise,
 and wraps non-promises in it. Simple enough, right? 
 But not only that. Thereâ€™s another keyword, await,
 that works only inside async functions, and itâ€™s pretty cool.

Await
The syntax:

// works only inside async functions
let value = await promise;
The keyword await makes JavaScript wait until that promise settles and returns its result.

Hereâ€™s an example with a promise that resolves in 1 second:

async function f() {

  let promise = new Promise((resolve, reject) => {
    setTimeout(() => resolve("done!"), 1000)
  });

  let result = await promise; // wait until the promise resolves (*)

  alert(result); // "done!"
}

f();
The function execution â€œpausesâ€ at the line (*) 
and resumes when the promise settles, with result becoming its result.
 So the code above shows â€œdone!â€ in one second.

Letâ€™s emphasize: await literally suspends the function execution until the promise settles,
 and then resumes it with the promise result. That doesnâ€™t cost any CPU resources,
 because the JavaScript engine can do other jobs in the meantime: execute other scripts, handle events, etc.

Itâ€™s just a more elegant syntax of getting the promise result than promise.then. And, itâ€™s easier to read and write.